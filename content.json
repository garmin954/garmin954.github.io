{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categorys","text":"","link":"/categorys/index.html"}],"posts":[{"title":"HEXO+ICARUS主题配置安装","text":"1 前言曾经折腾过Hexo+Next主题，但是很长时间都没有文章产出，因为习惯了使用印象笔记记录东西，现在想着换个主题，重新开始。 2 安装Git和Node.JS 2.1下载Git和Node.jsGit： https://git-scm.com/download/win/Node.js：https://nodejs.org/zh-cn/download/ 安装全部默认设置，一路Next即可。 3 安装Hexo 3.1下载Hexo创建好一个文件夹（不要在桌面），右键点击Git Bash Here,输入以下命令npm install -g hexo-cli 这个过程没有提示反馈，等待即可，大约1-2分钟即可，如果太久没有反应，【Ctrl+C】停止下载，可以将npm的源更改为淘宝镜像，输入以下命令，再尝试下载Hexo 12npm config set registry &quot;https://registry.npm.taobao.org/&quot;npm config set electron_mirror &quot;https://npm.taobao.org/mirrors/electron/&quot; 下载完成后初始化Hexohexo init完成后在初始化的路径下会有如下文件夹，后面标注对应作用 3.2运行Hexo使用以下命令生成博客并启动本地浏览 12hexo ghexo s 打开 http://localhost:4000 浏览，注意复制链接时不要使用【Ctrl+C】，因为这会停止本地浏览服务 3.3配置Hexo打开_config.yml，一般需要配置以下参数 123456789101112131415title: #网站标题author: #作者language: #语言（英语en，中文zh-CN）url: #网站url（域名）permalink: #文章链接（例article/:urlname.html）# Extensionstheme: #主题# Deploymentdeploy: type: repo: #仓库SSH地址 branch: permalink设置尽量短一些不含中文，并且可以设置一个urlname参数加html后缀，方便以后在文章头部设置该属性，实现自定义文章的url 3.4下载主题这里使用的icarus主题https://github.com/ppoffice/hexo-theme-icarus根据说明页，使用命令下载 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus或直接下载ZIP包 将下载的文件解压，复制到/theme/中,主题文件夹过长可以重命名为icarus，然后修改Hexo配置文件_config.yml中的themes参数 theme: icarus #主题重新使用命令即可本地预览效果 12hexo ghexo s 其他主题可以在GitHub上搜索hexo-theme https://github.com/search?q=hexo-theme 4 配置GitHub 4.1创建仓库登录GitHub账号后，打开 https://github.com/new页面创建仓库，参数默认即可，`注意仓库名称一定要符合 用户名.github.io 的格式 4.2创建SSH key输入命令（注意有引号），敲三下回车即可 ssh-keygen -t rsa -C &quot;邮箱地址&quot;之后在电脑用户目录如 C:\\Users\\Millet.ssh下生成了id_rsa和id_rsa.pub两个文件将id_rsa.pub文件中的内容复制，打开GitHub个人设置 SSH and GPG keys，点击New SSH key，粘贴到Key里面，标题随便取 输入命令，绑定GitHub账户 123456789git config --global user.email &quot;邮箱地址&quot;git config --global user.name &quot;用户名&quot; 测试连接ssh -T git@github.comyes 提示 You’ve successfully authenticated ，表明已经成功连接 4.3部署Hexo到GitHub安装部署插件npm install hexo-deployer-git --save修改Hexo配置文件_config.yml 123456789deploy: type: git repo: git@github.com:用户名/用户名.github.io.git #仓库SSH地址 branch: master 开始部署hexo ghexo d 等待一会，打开 https://用户名.github.io 即可看到效果 4.4绑定域名 1.在自己域名管理面板中添加CNAME记录，主机头为：www，值为：用户名.github.io2.在Hexo的\\source\\目录下创建一个CNAME.txt,输入你的域名，然后将txt后缀删除3.使用hexo g及hexo d部署到GitHub4.在GitHub仓库设置中,输入域名，开启SSL证书(注意必须要二级域名才能开启，不带主机头顶级域名无法开启) 5 主题配置 5.1主题参数配置导航栏显示及个人信息控件修改打开/themes/icarus/_config.yml，修改以下参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576navbar: # Navigation bar menu links menu: #菜单显示改为中文 首页: / 归档: /archives/ 分类: /categories/ 标签: /tags/ 关于: /about/ widgets: - # Widget name type: profile position: left #放置在左边栏 author: #作者 author_title: #作者标题 location: #位置信息 article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 文章显示修改article: #文章显示 # Code highlight settings highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制按钮 clipboard: true # 代码是否默认折叠. Can be &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 文章预览图 thumbnail: true # 阅读时间显示 readtime: true 控件位置修改配置文件中的控件代码先后顺序决定了网页中两栏控件的先后顺序 - # Widget name type: toc position: left #控件的位置 -删除控件如果需要去掉某个控件，那么可以在控件代码前加#，注意分割的符号 - 也要注释当然也可以直接删除代码# -# # Widget name# type: category# # Where should the widget be placed, left or right# position: left控件固定修改以下false为true可以让控件不随滚动条滚动sidebar: # left sidebar settings left: #左边栏固定 sticky: false # right sidebar settings right: #右边栏固定 sticky: false 5.2主题美化icarus这款主题为全局三栏显示，这样浏览文章时显得过于拥挤（宽屏显示器跳过），所以搜索了一下，如何让文章页拓宽一点，少显示些控件，最后找到了下面这篇帖子 Icarus 主题自定义 https://www.alphalxy.com/2019/03/customize-icarus/ 按照文章中的步骤配置即可，但是我测试后发现PC端成功改成了两栏，移动端布局错乱了，后面还是用了这位大佬的现成配置文件,感谢大佬分享。 现成配置文件 https://github.com/AlphaLxy/hexo-theme-icarus 使用方法：下载ZIP包，解压到Hexo的theme文件即可，按照上文的方法修改为自己的参数 底部访问量及运行时间修改 修改\\themes\\icarus\\layout\\common\\footer.ejs 文件，将原来只显示人数的span标签删除，添加以下代码 1234567891011121314151617181920 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 来访 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;, 总访问 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;02/20/2020 00:00:00&quot;); /*建站时间*/ now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; 再修改icarus配置文件，打开busuanzi统计 busuanzi: true 5.3插件暂时未使用太多插件，觉得博客简洁点好，不能花里胡哨，有空再弄吧 ╮(￣▽￣)╭ 5.4评论及分享参考icarus官方文章https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Share/ 6 常见问题修改配置或文章后浏览或部署到GitHub却未改变：1.尝试清理浏览器缓存2.使用hexo clean，删除生成的缓存，再重新hexo g3.删除部署到GitHub的缓存文件夹.deploy_git，重新生成及部署 7文章格式文章头部 1234567891011title: date: urlname: #自定义文章URLcategories: tags: - 标签thumbnail: #文章预览图comments: true #评论系统toc: true #目录mathjax: true #公式渲染 可以将文章头部保存到\\scaffolds\\post.md模板中，下次使用hexo n生成文章自带头部thumbnail参数可以填网址，也可以自己在\\source\\下创建一个images文件夹，将图片01.jpg放入，之后将thumbnail设置为/images/01.jpg即可调用————————————————「一粒米:D」的原创文章原文链接：https://blog.csdn.net/milletloks/java/article/details/104445557","link":"/2017/05/26/HEXO+ICARUS%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"},{"title":"js题目","text":"js笔试题目数组给定一个数组，编写一个函数去除重复元素 两种方法： 1) 遍历 + includes2) es6语法：Set()对象设置关联数组（关联数组的键唯一的），Array.form()转成索引数组 值类型和引用类型1）值类型： 字符串string，数值number，布尔值boolean， null, undefined2）引用类型： 对象 Object，数组Array，函数Function 值类型的赋值：直接将存储的数据复制一份进行赋值，两份数据在内存中是完全独立的。 引用类型赋值：引用类型的赋值的时候，是将变量中的存储的地址复制一份单独存储，但是两个变量中修改其中一个对象，另外一个引用来访问的时候，也会访问到修改后的值。 123456789101112131415161718class Person { constructor(name) { this.name = name; }; printName() { alert(this.name); }} var b = function(name) { this.name = name; } b.prototype.ok = function() { alert(this.name) } new Person('ok').printName(); new b('iii').ok();","link":"/2020/05/09/%E9%A2%98%E7%9B%AE/"},{"title":"算法/复杂度分析和大O表示法","text":"","link":"/2020/05/09/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/"},{"title":"学习计划-前端","text":"最近感觉自己是一个失败的程序员 有点迷茫，特别是看到各类技术网站上别人的文章 “面试”,”office”,”工资”，这些标签对我来说是特别的刺眼，刺伤了我的羞耻心！是的！没有必要再这样迷茫，彷徨下去了！给自己一个学习计划，克服懒惰和杂念！只要坚定和坚信 I will win 计算机网络协议基础html css 基础javascript 基础框架webpack","link":"/2020/04/30/articles/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%89%8D%E7%AB%AF/"},{"title":"学习写作","text":"一，为什么要学习写作 记录工作生活的问题解决方法和经验总结 提升自己的语言构思能力和逻辑能力 二，怎么写作 一篇技术文章，除了刚我们说的这种结构体，还有开篇、总结、呼吁行动等环节。综合起来，常见的技术文章组织结构如下： 开篇，这部分阐明文章讲什么、能带给读者什么价值； 结构体，按照一定的结构，展开叙述，比如时间线、比如走读代码的逻辑、比如设计演示示例的过程（问题-设计思路-代码演示-代码解读-结果展示）、比如QA（问题-答案）、比如并列条目、比如总分总、比如实战小项目的讲解过程（项目背景-效果展示-设计解释-代码演示-代码解读-延伸场景）等； 总结，一段话，回顾讲过的要点，点出读者应该注意的地方； 呼吁行动，可以一两句话，呼吁读者自己设计代码、动手试试，或者给出一些练习题，让读者去做。 2.1 开篇 文章的开头部分，往往决定着读者是否愿意继续看下去，因此切入点要足够精准，足够切题，且足够有吸引力。 这部分阐明文章讲什么、能带给读者什么价值； 2.2 结构体 各个部分也需要串成串，那就需要我们加入一定的呼应。我们的文章可以分成多个部分，但所有部分务必应该为题目，也就是主题服务。因此在各部分之间，就需要出现必要的呼应， 2.3 总结 一段话，回顾讲过的要点，点出读者应该注意的地方；","link":"/2020/04/16/articles/%E5%AD%A6%E4%B9%A0%E5%86%99%E4%BD%9C/"},{"title":"php/基础","text":"### 用于防SQL注入的几个函数 addslashes()在预定义字符前面加反斜线 单引号（’） 双引号（”） 反斜杠（\\） NULL","link":"/2020/06/02/php/%E5%9F%BA%E7%A1%80/"},{"title":"Laravel学习规划","text":"前言：打算学完最后一个php框架laravel，最后的垂死挣扎？？？ 当然没有这是已久想完成的事，而这一次必将实现它！哈哈😄用时： 12-25 天学习并掌握laravel 规划第一步第一步还是使用模板混合开发模式学习地址：Laravel 教程 - Web 开发实战进阶规划时间：2-5天学习内容：基础知识 第二步前后端分离第二步看看学院君的课程学习地址：基于 Laravel + Vue 构建前后端分离应用规划时间：2-5天学习内容：前后端分离 第三步巩固前后端分离第三步巩固知识点学习地址：实战构架 API 服务器规划时间：2-5天学习内容：前后端分离 第四步 实战商城项目第三步巩固知识点➕拓展项目经验学习地址：电商实战 ,电商进阶规划时间：5-10天学习内容：商城项目开发经验 OVER 希望至此的我了却了这个愿望了，并能熟练的使用laravel这门框架！！！","link":"/2020/05/14/php/%E5%AD%A6%E4%B9%A0Laravel%E8%A7%84%E5%88%92/"},{"title":"前端基础/页面结构语义化","text":"1. 为什么需要语义化？ 易维护，易修改，易阅读 有利于搜索引擎爬取（seo） 2. 语义化是什么？ 语义元素均有一个共同特点——他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。 2.1 头部&lt;header&gt;元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其它信息的情况下：发布时间、作者等），一般不在内容中使用&lt;header&gt;因而，网页中可以包含多个&lt;header&gt;元素。按照 HTML5 的规定，&lt;header&gt;都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为display: none; 一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。 2.2 导航栏导航栏使用&lt;nav&gt;看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个元素，但通常仅仅在页面的主要导航部分使用它。 附注 &lt;aside&gt;元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用&lt;aside&gt;元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。 当&lt;aside&gt;用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。 侧栏中的&lt;section&gt;元素规定了一个区域，通常是带有标题的内容。 标签适合标记的内容区块： 与页面主体并列显示的小内容块。 独立性内容，清单、表单等。 分组内容，如 CMS 系统中的文章分类区块。 比较长文档的一部分，可能仅仅是为了正确规定页面大纲。&lt;div&gt;标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！ 2.3 页脚 同可“包罗万象”的&lt;header&gt;元素不同，标准规定&lt;footer&gt;标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。 如果想要在页脚中包含其它内容，可以使用熟悉的&lt;div&gt;来帮忙。 2.4 主要内容在早先的 HTML5 版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。 然而，HTML5.1 中规定了一个&lt;main&gt;标签来标识主体内容。&lt;main&gt;标签不能包含在页面其它区块元素中，通常是&lt;body&gt;的子标签，或者是全局&lt;div&gt;的子标签。&lt;main&gt;标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。 2.5 文章&lt;article&gt;表示一个完整的、自成一体的内容块。如文章或新闻报道。&lt;article&gt;应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用&lt;article&gt;标记。 文章中包含插图时，使用新的语义元素&lt;figure&gt;标签。 12345678910&lt;article&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt; &lt;!-- 内容 --&gt; &lt;/p&gt; &lt;figure&gt; &lt;img src=&quot;#&quot; alt=&quot;插图&quot;&gt; &lt;figcaption&gt;这是一个插图&lt;/figcaption&gt; &lt;/figure&gt;&lt;/article&gt; 上述情况下，&lt;figcaption&gt;包含了关于插图的详细解释，则&lt;img&gt;的alt属性可以略去。 3. 参考转自雨落博客","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/09/web/hello-world/"},{"title":"argument","text":"总所周知，js是一门相当灵活的语言。当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，那么这到底是什么东西？ 在js中万物皆对象，甚至数组字符串函数都是对象。所以这个叫做arguments的东西也是个对象，而且是一个特殊的对象，它的属性名是按照传入参数的序列来的，第1个参数的属性名是’0’，第2个参数的属性名是’1’，以此类推，并且它还有length属性，存储的是当前传入函数参数的个数，很多时候我们把这种对象叫做类数组对象。类数组对象和数组都是对象这个妈生的，但是数组是大哥比类数组对象多了很多其他的玩具(方法)，类数组对象只是长得很像数组的弟弟而已。 慢着，刚刚不是说数组也是对象吗，现在这个类数组对象又是什么？ 没办法，js就是这么的灵活。这个类数组对象不仅存储给函数传入的参数，也具有一些其他的属性，等下会一一道来。 因为类数组对象和数组有很多的共性，所以我们经常可以用call方法，让类数组对象也使用的数组的一些方法，就是让这个弟弟去玩哥哥的玩具，比如……，还是不扯远了，这篇文章只是说什么是arguments，想知道更多关于对象如何借调数组方法的话，请参考这篇文章。 下面举个栗子： 12345678910function add() { if( arguments.length == 2 ){ return arguments[0] + arguments[1]; }else{ return '传入参数不合法'; }} console.log( add(2,3) );console.log( add(1,2,3) ); 看看结果： 结果 最后我们还可以看到arguments还有一个叫做callee的属性，这个属性是表示的是当前函数的一个引用，简单点说，这个属性里面存储的我们调用的这个函数的代码，实在无法理解的时候，又到了console.log大显身手的时候了。 12345678910function showcallee() { var a = '这里是代码'; var b = '这是另一段代码'; var c = a + b; console.log(arguments.callee); return c;}showcallee(); 结果 看到结果的你是不是和我一样惊呆了呢，这不就是我写的代码吗，arguments.callee完完整整的把这个函数的这段代码返回了。 arguments的一些妙用1.利用arguments实现方法的重载下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。 12345678910111213function add() { var len = arguments.length, sum = 0; for(;len--;){ sum += arguments[len]; } return sum;} console.log( add(1,2,3) ); //6console.log( add(1,3) ); //4console.log( add(1,2,3,5,6,2,7) ); //26 由于js是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。 2.利用arguments.callee实现递归先来看看之前我们是怎么实现递归的，这是一个结算阶乘的函数 1234567function factorial(num) { if(num&lt;=1) { return 1; }else { return num * factorial(num-1); } } 但是当这个函数变成了一个匿名函数时，我们就可以利用callee来递归这个函数。 1234567function factorial(num) { if(num&lt;=1) { return 1; }else { return num * arguments.callee(num-1); } } 这个方法虽然好用，但是有一点值得注意，ECMAScript4中为了限制js的灵活度，让js变得严格，新增了严格模式，在严格模式中我们被禁止不使用var来直接声明一个全局变量，当然这不是重点，重点是arguments.callee这个属性也被禁止了。不过这都不是事儿，ES6为我们新增了很多好用的变量声明方式和新的语法糖，作为一个时髦的前端，我们赶紧学习一些ES6的新语法吧。","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/arguments/"},{"title":"Vue之Mixins(混入)","text":"","link":"/2020/05/09/web/vue/Vue%E4%B9%8BMixins(%E6%B7%B7%E5%85%A5)/"},{"title":"php面试题目解知","text":"php面试题目解知 1.表单提交中的Get和Post的异同点 参考文章","link":"/2020/05/17/php/%E9%9D%A2%E8%AF%95/php%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%A7%A3/"},{"title":"php/工具/php反射获取类和方法中的注释","text":"title: php反射获取类和方法中的注释 date: 2020-05-15 21:15:57categories: php toc: true 获取一个类里面所有的方法，和注释的工具！这样编程就容易多了！ 通过php中的反射机制，获取该类的文档注释，再通过获取其所有的方法，获取方法的注释 所用到的主要类及其方法 &lt;?php ReflectionClass ReflectionClass::getDocComment ReflectionClass::getMethods $method-&gt;getName(); $method-&gt;getDocComment(); $method-&gt;isProtected(); $method-&gt;getParameters(); $param-&gt;getName(); $param-&gt;isDefaultValueAvailable(); $param-&gt;getDefaultValue(); 测试类如下： test.php &lt;?php header(\"Content-type: text/html; charset=utf-8\"); require_once dir(__DIR__).'function.php'; require_once dir(__DIR__).'TestClass.php'; $class_name = 'TestClass'; $reflection = new ReflectionClass ( $class_name ); //通过反射获取类的注释 $doc = $reflection-&gt;getDocComment (); //解析类的注释头 $parase_result = DocParserFactory::getInstance()-&gt;parse ( $doc ); $class_metadata = $parase_result; //输出测试 var_dump ( $doc ); echo \"\\r\\n\"; print_r( $parase_result ); echo \"\\r\\n-----------------------------------\\r\\n\"; //获取类中的方法，设置获取public,protected类型方法 $methods = $reflection-&gt;getMethods(ReflectionMethod::IS_PUBLIC + ReflectionMethod::IS_PROTECTED + ReflectionMethod::IS_PRIVATE); //遍历所有的方法 foreach ($methods as $method) { //获取方法的注释 $doc = $method-&gt;getDocComment(); //解析注释 $info = DocParserFactory::getInstance()-&gt;parse($doc); $metadata = $class_metadata + $info; //获取方法的类型 $method_flag = $method-&gt;isProtected();//还可能是public,protected类型的 //获取方法的参数 $params = $method-&gt;getParameters(); $position=0; //记录参数的次序 foreach ($params as $param){ $arguments[$param-&gt;getName()] = $position; //参数是否设置了默认参数，如果设置了，则获取其默认值 $defaults[$position] = $param-&gt;isDefaultValueAvailable() ? $param-&gt;getDefaultValue() : NULL; $position++; } $call = array( 'class_name'=&gt;$class_name, 'method_name'=&gt;$method-&gt;getName(), 'arguments'=&gt;$arguments, 'defaults'=&gt;$defaults, 'metadata'=&gt;$metadata, 'method_flag'=&gt;$method_flag ); print_r($call); echo \"\\r\\n-----------------------------------\\r\\n\"; } function.php &lt;?php require_once dir(__DIR__).'DocParser.php'; /** * 解析doc * 下面的DocParserFactory是对其的进一步封装，每次解析时，可以减少初始化DocParser的次数 * * @param $php_doc_comment * @return array */ function parse_doc($php_doc_comment) { $p = new DocParser (); return $p-&gt;parse ( $php_doc_comment ); } /** * Class DocParserFactory 解析doc * * @example * DocParserFactory::getInstance()-&gt;parse($doc); */ class DocParserFactory{ private static $p; private function DocParserFactory(){ } public static function getInstance(){ if(self::$p == null){ self::$p = new DocParser (); } return self::$p; } } TestClass.php &lt;?php /** * A test class 在此处不能添加@ur,@param,@return 注释 * 如果要将类的注释和方法的注释合并的话，添加了上面的注释，会将方法中的注释给覆盖掉 */ class TestClass { /** * @desc 获取public方法 * * @url GET pnrs * @param array $request_data * @return int id */ public function getPublicMethod($no_default,$add_time = '0000-00-00') { echo \"public\"; } /** * @desc 获取private方法 * * @url GET private_test * @return int id */ private function getPrivateMethod($no_default,$time = '0000-00-00') { echo \"private\"; } /** * @desc 获取protected方法 * * @url GET protected_test * @param $no_defalut,$time * @return int id */ protected function getProtectedMethod($no_default,$time = '0000-00-00') { echo \"protected\"; } } DocParser.php 该类源自一个开源项目 &lt;?php /** * Parses the PHPDoc comments for metadata. Inspired by Documentor code base * @category Framework * @package restler * @subpackage helper * @author Murray Picton &lt;info@murraypicton.com&gt; * @author R.Arul Kumaran &lt;arul@luracast.com&gt; * @copyright 2010 Luracast * @license http://www.gnu.org/licenses/ GNU General Public License * @link https://github.com/murraypicton/Doqumentor */ class DocParser { private $params = array (); function parse($doc = '') { if ($doc == '') { return $this-&gt;params; } // Get the comment if (preg_match ( '#^/\\*\\*(.*)\\*/#s', $doc, $comment ) === false) return $this-&gt;params; $comment = trim ( $comment [1] ); // Get all the lines and strip the * from the first character if (preg_match_all ( '#^\\s*\\*(.*)#m', $comment, $lines ) === false) return $this-&gt;params; $this-&gt;parseLines ( $lines [1] ); return $this-&gt;params; } private function parseLines($lines) { foreach ( $lines as $line ) { $parsedLine = $this-&gt;parseLine ( $line ); // Parse the line if ($parsedLine === false &amp;&amp; ! isset ( $this-&gt;params ['description'] )) { if (isset ( $desc )) { // Store the first line in the short description $this-&gt;params ['description'] = implode ( PHP_EOL, $desc ); } $desc = array (); } elseif ($parsedLine !== false) { $desc [] = $parsedLine; // Store the line in the long description } } $desc = implode ( ' ', $desc ); if (! empty ( $desc )) $this-&gt;params ['long_description'] = $desc; } private function parseLine($line) { // trim the whitespace from the line $line = trim ( $line ); if (empty ( $line )) return false; // Empty line if (strpos ( $line, '@' ) === 0) { if (strpos ( $line, ' ' ) &gt; 0) { // Get the parameter name $param = substr ( $line, 1, strpos ( $line, ' ' ) - 1 ); $value = substr ( $line, strlen ( $param ) + 2 ); // Get the value } else { $param = substr ( $line, 1 ); $value = ''; } // Parse the line and return false if the parameter is valid if ($this-&gt;setParam ( $param, $value )) return false; } return $line; } private function setParam($param, $value) { if ($param == 'param' || $param == 'return') $value = $this-&gt;formatParamOrReturn ( $value ); if ($param == 'class') list ( $param, $value ) = $this-&gt;formatClass ( $value ); if (empty ( $this-&gt;params [$param] )) { $this-&gt;params [$param] = $value; } else if ($param == 'param') { $arr = array ( $this-&gt;params [$param], $value ); $this-&gt;params [$param] = $arr; } else { $this-&gt;params [$param] = $value + $this-&gt;params [$param]; } return true; } private function formatClass($value) { $r = preg_split ( \"[\\(|\\)]\", $value ); if (is_array ( $r )) { $param = $r [0]; parse_str ( $r [1], $value ); foreach ( $value as $key =&gt; $val ) { $val = explode ( ',', $val ); if (count ( $val ) &gt; 1) $value [$key] = $val; } } else { $param = 'Unknown'; } return array ( $param, $value ); } private function formatParamOrReturn($string) { $pos = strpos ( $string, ' ' ); $type = substr ( $string, 0, $pos ); return '(' . $type . ')' . substr ( $string, $pos + 1 ); } }","link":"/2020/05/24/php/%E5%B7%A5%E5%85%B7/php%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/"},{"title":"按住三秒的事件","text":"12@touchstart.prevent=&quot;touchin(i, $event)&quot;@touchend.prevent=&quot;cleartime()&quot; 12345678910111213141516171819202122232425262728293031323334// 500表示触屏时间，可以根据实际情况写，只要达到这个时间就会触发setTimeout里的事件// 删除图片方法touchin(index, obj){ var _self=this; this.Loop = setTimeout(function() { _self.Loop = 0; //执行长按要执行的内容，如弹出菜单 wx.showModal({ title: '提示', content: '确认删除图片', success: function (res) { if (res.confirm) { // 删除操作 _self.images_list.splice(index, 1); } else if (res.cancel) { // 取消操作 } } }); }, 500); return false;},// 触屏离开的事件cleartime(index) { var that=this; clearTimeout(this.Loop); if(that.Loop!=0){ //这里写要执行的内容（尤如onclick事件） // that.previewPicture(index) } return false;},","link":"/2020/05/09/web/%E4%BA%8B%E4%BB%B6/js%E9%95%BF%E6%8C%893%E7%A7%92%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6/"},{"title":"vue保持用户在线状态","text":"保持用户登录状态， 图例","link":"/2020/06/24/web/vue/vue%E4%BF%9D%E6%8C%81%E7%94%A8%E6%88%B7%E5%9C%A8%E7%BA%BF%E7%8A%B6%E6%80%81/"},{"title":"小程序登录流程","text":"先放一张小程序官方登录流程时序压压惊 第一步： 前端 wx.login 获取code 第二步： 前端 通过button按钮获取 iv 和 encryptedData 123&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot; lang=&quot;zh_CN&quot; type=&quot;primary&quot;&gt; 授权登录&lt;/button&gt; 第三步：前端 wx.request 携带 code, iv, encryptedData 请求接口，服务器端 拿去code 请求微信接口 换取 openid ,session_key 第四步：服务端 查看数据库是否存在用户，不存在时用session_key进行解密（得到用户信息），存在时直接执行第五步 第五步：服务端生产token返回给前端 第六步：前端处理token和登录状态 我的简约思维导图 前端登录状态及token存储More info: Writing","link":"/2020/05/09/web/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"},{"title":"vuex状态管理基础详情","text":"一，Vuex 状态状态管理1.1 什么是 vuex 状态状态管理 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能 1.2 为什么要使用vuex 解决了什么难题 二，Vuex基础三，怎么使用Vuex四，注意事项","link":"/2020/04/16/web/vue/Vue%E4%B9%8Bvuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"},{"title":"es6知识点","text":"变量字符串数组对象","link":"/2020/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/es6%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"彻底理解this指向","text":"this：当前执行代码的环境对象，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值，具体官方详细介绍 作用：便捷的获取使用所指向环境的“属性”，“方法” 全局window在全局作用域下使用this,得到的是顶层对象window 123this// Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}console.log(this === window); // true 然而，在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined。 123456function f2(){ \"use strict\"; // 这里是严格模式 return this;}f2() === undefined; // true 所以，在严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined。 请看第5点 函数普通函数普通函数这里是指使用function 声明的函数 1234567var obj ={ func:function(){ console.log(this) }}obj.func()// VM7926:3 {func: ƒ} 上面代码可以看出普通函数this指向当前调用的对象obj. this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this指向的是window；当函数被作为某个对象的方法调用时，this就等于那个对象。 闭包函数this指向retrun出来函数的执行环境 12345678910111213141516171819var name = \"window\";var object = { name : \"object\", getNameFunc : function(){ return function(){ return this.name; }; }};var obj = { name : \"obj\", getNameFunc : object.getNameFunc()};function foo() { return this.name;}console.log(foo());//Windowconsole.log(object.getNameFunc()()); //Windowconsole.log(obj.getNameFunc());//obj 闭包函数无法直接访问包含他的函数的this对象, 因为二者的this指向是不一样的,外部函数的this指向调用他的对象, 闭包内部函数的this指向了全局对象, 其实并不难理解.实际上, 当调用object.getNameFunc()时, 就像全局对象返回了一个函数, 返回的这个函数和foo函数其实并无两样.在全局中调用这个返回的函数时, 函数的this自然就指向了全局对象, 就好像调用foo函数一样. 而当object.getNameFunc()在obj内部时, 返回的闭包函数就成了obj 的属性, 此时闭包函数的this就指向了obj对象. 箭头函数箭头函数中this指向当前封闭环境，在全局代码中，它将被设置为全局对象 1234567891011121314var object = { name: \"object\", getNameFunc: function() { return ()=&gt;{ return this.name; }; }};var obj = { name : \"obj\", getNameFunc : object.getNameFunc()};console.log(object.getNameFunc()()); //objectconsole.log(obj.getNameFunc());//object 上面代码看出，this一直指向的是object这个封闭的词法环境 构造函数这个就不做太多解释了，当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象，不了解看官方介绍 原型链中的 this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。 12345678910var o = { f: function() { return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 更换绑定环境把 this 的值从一个环境传到另一个环境 call 和 apply12345678910var obj = {a: 'Custom'};// 这个属性是在global对象定义的。var a = 'Global';function whatsThis(arg) { return this.a; // this的值取决于函数的调用方式}whatsThis(); // 'Global'whatsThis.call(obj, 'is_a'); // 'Custom'whatsThis.apply(obj, ['is_a']); // 'Custom' apply 和 call 的差别只是参数传递方式不一样 bindes5就加入了改方法，同样是更改this指向环境，不过bind 是调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的 123456789101112function f(){ return this.a;}var g = f.bind({a:\"azerty\"});console.log(g()); // azertyvar h = g.bind({a:'yoo'}); // bind只生效一次！console.log(h()); // azertyvar o = {a:37, f:f, g:g, h:h};console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty","link":"/2020/05/06/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/this%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91/"},{"title":"const常量基础详解","text":"什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细声明constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5; }MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 123456const foo = {};foo.prop = 123;foo.prop// 123foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。 1234const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性(window)顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量 a 由var命令声明，所以它是顶层对象的属性；全局变量 b 由let 命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中,this会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; }// Web Worker if (typeof window !== 'undefined') { return window; } // windew if (typeof global !== 'undefined') { return global; } // node环境 throw new Error('unable to locate global object');}; 现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。 globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 我的总结1.const 本质：const定义一个常量 指向一个内存地址不变，但不能影响内存的数据变化（比如：复合型变量(数组，对象)） 和let一样有 暂时性死区,不能在声明前使用 没有变量提升 2.顶层对象属性 顶层对象的属性与全局变量是等价的 (window) es6有声明变量的方法，两种var,function声明全局变量，还有let,const,class,import 3.Global对象 浏览器里面里使用window web Workerself Node 里使用global 三种环境都能用globalThis","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/const%E5%B8%B8%E9%87%8F%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"变量的解构与赋值","text":"定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10.定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. 定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10.定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. 什么是const常量定义常量,常量就是不变的值，用在函数，变量，数组，指针类型说明前（如：const int a=10;）表示的a值永远是10. const详细","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"循环遍历","text":"循环数组原始for12345// const fruits = {apple:'apple',banana:'banana',grape:'grape'};const fruits = ['apple','banana','grape'];for (let i=0; i &lt; fruits.length; i++){ console.log(fruits[i])} es5 forEach1234567const fruits = ['apple','banana','grape'];fruits.forEach((key,value)=&gt;{ console.log(key); console.log(value); // 不支持 break, continue}) 不支持break,continue es6 for-of12345678910111213const fruits = ['apple','banana','grape'];for ( let value of fruits){ console.log(value);}// apple// banana// grape for ( let value of fruits.entries()){ console.log(value); }// [0, \"apple\"]// [1, \"banana\"]// [2, \"grape\"]","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/"},{"title":"let和var基础详解","text":"let是什么 ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 123456{ let a = 10; var b = 1;}console.log(a) // ReferenceError: a is not defined.console.log(b) // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) {}console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 为什么要使用它不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 12345var tmp = 123;if (true) { tmp = 'abc'; // ReferenceError let tmp;} 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。 1234567891011if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123} 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // \"undefined\" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 12345function bar(x = y, y = 2) { return [x, y];}bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 有些“死区”比较隐蔽，不太容易发现。ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() { let a = 10; var a = 1;}// 报错function func() { let a = 10; let a = 1;} 因此，不能在函数内部重新声明参数。 12345678910function func(arg) { let arg; // 报错}function func(arg) { { console.log(arg); let arg; // 不报错 }} 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() { console.log(tmp); // 变量提升函数先于全局 if (false) { var tmp = \"hello world\"; }}f(); // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); // 真的可以做数组来取}console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 1234567function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5} 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。 ES6允许块级作用域的任意嵌套。 12345{ { {let insane = 'Hello World'} }}; 上面代码使用了一个三层的块级作用域。外层作用域无法读取内层作用域的变量。 1234{{{{ {let insane = 'Hello World'} console.log(insane); // 报错}}}}; 内层作用域可以定义外层作用域的同名变量。 1234{{{{ let insane = 'Hello World'; {let insane = 'Hello World'}}}}}; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法 匿名函数自调用(IIFE) 变量只在函数里有用(function () { var tmp = ...; ...}());// 块级作用域写法{ let tmp = ...; ...} 块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。 ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 12345678910// 情况一if (true) { function f() {}}// 情况二try { function f() {}} catch(e) {} 上面代码的两种函数声明，根据ES5的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。 123456// ES5严格模式'use strict';if (true) { function f() {}}// 报错 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。 123456// ES6严格模式'use strict';if (true) { function f() {}}// 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 123456789function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 12345678// ES5版本function f() { console.log('I am outside!'); }(function () { function f() { console.log('I am inside!'); } if (false) { } f();}()); ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。 12345// ES6版本function f() { console.log('I am outside!'); }(function () { f();}()); 很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 前面那段代码，在 Chrome 环境下运行会报错。 1234567891011// ES6的浏览器环境function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}());// Uncaught TypeError: f is not a function 上面的代码报错，是因为实际运行的是下面的代码。 12 // ES6的浏览器环境function f() { console.log(‘I am outside!’); }(function () { var f = undefined; if (false) { function f() { console.log(‘I am inside!’); } } f();}());// Uncaught TypeError: f is not a function考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 函数声明语句{ let a = 'secret'; function f() { return a; }}// 函数表达式{ let a = 'secret'; let f = function () { return a; };} 另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 不报错'use strict';if (true) { function f() {}}// 报错'use strict';if (true) function f() {} do 表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 1234{ let t = f(); t = t * t + 1;} 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。 1234let x = do { let t = f(); t * t + 1;}; 上面代码中，变量x会得到整个块级作用域的返回值。 我的总结1.变量提升 let没有变量提升，var有变量提升 提升优先级： 变量 &gt; 函数 &gt; 参数 &gt; 提升 2.暂时性死区 在let已声明变量的作用域里变量已存在，但不能使用，在声明语句后面才能正常使用 es6用来规范变量的使用 3.不允许重复声明 let变量在同一作用域只能声明一次 4.块级作用域 let只能在当前作用域使用","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/let%E5%92%8Cvar%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"计算机网络协议","text":"由来： 是什么：","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"title":"字符串函数大全","text":"字符串属性 [waring] 所有 String 的实例都继承自 String.prototype. 任何String.prototype上的改变都会影响到所有的 String 实例。 字符串方法返回特定位置的字符(charAt)String.prototype.charAt() 12let str = 'garmin';str.charAt(2); // r 返回表示给定索引的字符的Unicode的值String.prototype.charCodeAt() 12let str = 'garmin';str.charCodeAt(2); // 114 返回使用UTF-16编码的给定位置的值的非负整数String.prototype.codePointAt() 12let str = 'garmin';str.codePointAt(2); // 114 连接两个字符串文本，并返回一个新的字符串String.prototype.concat() 1234let str1 = 'garmin';let str2 = ' javascript';str1.concat(str2); // garmin javascript 判断一个字符串里是否包含其他字符串String.prototype.includes() 12let str = 'garmin';str.includes('g'); // true 判断一个字符串的是否以给定字符串结尾，结果返回布尔值String.prototype.endsWith() 12let str = 'garmin';str.endsWith('n'); // true 从字符串对象中返回首个被发现的给定值的索引值，如果没有找到则返回-1String.prototype.indexOf() 12let str = 'garmin';str.indexOf('g'); // 0 lastIndexOf 返回一个数字表示是否引用字符串在排序中位于比较字符串的前面，后面，或者二者相同String.prototype.localeCompare() 123let str = 'garmin';str.localeCompare('g'); // 1str.localeCompare(','); // 1 使用正则表达式与字符串相比较。String.prototype.match() 12let str = 'What is garmin';str.match('garmin'); // ['garmin'] 返回调用字符串值的Unicode标准化形式String.prototype.normalize() 12let str = 'What is garmin';str.normalize(); // ** 字符串补全padEnd / padStart 12let str = 'What is garmin';str.padEnd(20, '0'); // \"What is garmin000000\" 我的总结","link":"/2020/05/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8/"},{"title":"变量的解构与赋值","text":"变量的解构与赋值 什么是变量的解构与赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123456let a = 1;let b = 2;let c = 3;// ES6 允许写成下面这样。let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = {}; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // \"a\" 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() { let a = 0; let b = 1; while (true) { yield a; [a, b] = [b, a + b]; }}let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是 null，默认值就不会生效，因为null不严格等于undefined[warning] 只有当一个数组成员严格等于undefined，默认值才会生效 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() { console.log('aaa');}let [x = f()] = [1]; 上面代码中，因为 x 能取到值，所以函数 f 根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) { x = f();} else { x = [1][0];} 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。 let 暂时性死区 对象的解构赋值简介解构不仅可以用于数组，还可以用于对象。 123let { foo, bar } = { foo: 'aaa', bar: 'bbb' };foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let { bar, foo } = { foo: 'aaa', bar: 'bbb' };foo // \"aaa\"bar // \"bbb\"let { baz } = { foo: 'aaa', bar: 'bbb' };baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果解构失败，变量的值等于undefined。 12let {foo} = {bar: 'baz'};foo // undefined 上面代码中，等号右边的对象没有foo属性，所以变量foo取不到值，所以等于undefined。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 123456// 例一let { log, sin, cos } = Math;// 例二const { log } = console;log('hello') // hello 上面代码的例一将 Math 对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。 如果变量名与属性名不一致，必须写成下面这样。 1234567let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // \"aaa\"let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 1let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // \"aaa\"foo // error: foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = { p: [ 'Hello', { y: 'World' } ]};let { p: [x, { y }] } = obj;x // \"Hello\"y // \"World\" 注意，这时 p 是模式，不是变量，因此不会被赋值。如果 p 也要作为变量赋值，可以写成下面这样。 1234567891011let obj = { p: [ 'Hello', { y: 'World' } ]};let { p, p: [x, { y }] } = obj;x // \"Hello\"y // \"World\"p // [\"Hello\", {y: \"World\"}] 下面是另一个例子。 12345678910111213const node = { loc: { start: { line: 1, column: 5 } }};let { loc, loc: { start }, loc: { start: { line }} } = node;line // 1loc // Object {start: Object}start // Object {line: 1, column: 5} 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc 和 start 都是模式，不是变量。 下面是嵌套赋值的例子。 1234567let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });obj // {prop:123}arr // [true] 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错let {foo: {bar}} = {baz: 'baz'}; 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于undefined，再取子属性就会报错。 注意，对象的解构赋值可以取到继承的属性。 123456const obj1 = {};const obj2 = { foo: 'bar' };Object.setPrototypeOf(obj1, obj2);const { foo } = obj1;foo // \"bar\" 上面代码中，对象 obj1 的原型对象是 obj2 。foo 属性不是 obj1 自身的属性，而是继承自 obj2 的属性，解构赋值可以取到这个属性。 默认值对象的解构也可以指定默认值。 123456789101112131415var {x = 3} = {};x // 3var {x, y = 5} = {x: 1};x // 1y // 5var {x: y = 3} = {};y // 3var {x: y = 3} = {x: 5};y // 5var { message: msg = 'Something went wrong' } = {};msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var {x = 3} = {x: undefined};x // 3var {x = 3} = {x: null};x // null 注意点（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234// 错误的写法let x;{x} = {x: 1};// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;({x} = {x: 1}); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 （2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123({} = [true, false]);({} = 'abc');({} = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 （3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let {0 : first, [arr.length - 1] : last} = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。 12let {length : len} = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y]){ return x + y;}add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move({x = 0, y = 0} = {}) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, 0]move({}); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move({x, y} = { x: 0, y: 0 }) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, undefined]move({}); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 变量声明语句123456789// 全部报错let [(a)] = [1];let {x: (c)} = {};let ({x: c}) = {};let {(x: c)} = {};let {(x): c} = {};let { o: ({ p: p }) } = { o: { p: 2 } }; 函数参数函数参数也属于变量声明，因此不能带有圆括号。 1234// 报错function f([(z)]) { return z; }// 报错function f([z,(x)]) { return x; } 赋值语句的模式123// 全部报错({ p: a }) = { p: 42 };([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[({ p: a }), { x: c }] = [{}, {}]; 上面代码将一部分模式放在圆括号之中，导致报错。 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确({ p: (d) } = {}); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() { return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() { return { foo: 1, bar: 2 };}let { foo, bar } = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1}); 提取 JSON 数据解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = { id: 42, status: \"OK\", data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config} = {}) { // ... do stuff}; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) { console.log(key + \" is \" + value);}// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) { // ...}// 获取键值for (let [,value] of map) { // ...} 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const { SourceMapConsumer, SourceNode } = require(\"source-map\"); 我的总结1 数组的解构赋值 “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 不完全解构 即等号左边的模式，只匹配一部分的等号右边的数组 如果等号的右边不是数组（或者严格地说，不是可遍历的结构）就会报错 只有当一个数组成员严格等于undefined，默认值才会生效（ES6 内部使用严格相等运算符（===），判断一个位置是否有值） 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 2 对象的解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。否则变量为undefined 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 对象的解构赋值可以取到继承的属性。 3 字符串的解构赋值 4 字符串的解构赋值 字符串被转换成了一个类似数组的对象。 5 数值和布尔值的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 6.用途 交换变量的值 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 结构 输入模块的指定方法","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/"},{"title":"字符串的扩展","text":"字符串的扩展 字符的 Unicode 表示法ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 12\"\\u0061\"// \"a\" 但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345\"\\uD842\\uDFB7\"// \"𠮷\"\"\\u20BB7\"// \" 7\" 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011\"\\u{20BB7}\"// \"𠮷\"\"\\u{41}\\u{42}\\u{43}\"// \"ABC\"let hello = 123;hell\\u{6F} // 123'\\u{1F680}' === '\\uD83D\\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u{7A}' === 'z' // true 字符串的遍历器接口ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。 123456for (let codePoint of 'foo') { console.log(codePoint)}// \"f\"// \"o\"// \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// \" \"// \" \"for (let i of text) { console.log(i);}// \"𠮷\" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。 1'中' === '\\u4e2d' // true 但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。 12345U+005C：反斜杠（reverse solidus)U+000D：回车（carriage return）U+2028：行分隔符（line separator）U+2029：段分隔符（paragraph separator）U+000A：换行符（line feed） 举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\或者\\u005c。 这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。 这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。 12const json = '\"\\u2028\"';JSON.parse(json); // 可能报错 JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。 1const PS = eval(\"'\\u2029'\"); 根据这个提案，上面的代码不会报错。 注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。 JSON.stringify() 的改造 根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。 具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。 比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。 这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的， 或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify('\\u{D834}') // \"\\u{D834}\" 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 12JSON.stringify('\\u{D834}') // \"\"\\\\uD834\"\"JSON.stringify('\\uDF06\\uD834') // \"\"\\\\udf06\\\\ud834\"\" 模板字符串传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello ${name}, how are you ${time}?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) { if (!user.hasPrivilege(action)) { throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User ${user.name} is not authorized to do ${action}.`); }} 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`${x} + ${y} = ${x + y}`// \"1 + 2 = 3\"`${x} + ${y * 2} = ${x + y * 2}`// \"1 + 4 = 5\"let obj = {x: 1, y: 2};`${obj.x + obj.y}`// \"3\" 模板字符串之中还能调用函数。 123456function fn() { return \"Hello World\";}`foo ${fn()} bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 123// 变量place没有声明let msg = `Hello, ${place}`;// 报错 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello ${'World'}`// \"Hello World\" 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' },];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以写成函数。 12let func = (name) =&gt; `Hello ${name}!`;func('Jack') // \"Hello Jack!\" 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 实例：模板编译 下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) { echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');};echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output;})`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template){ const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output; })`; return script;} compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 我的总结1 字符串的遍历器接口 for (let i of ...)除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点 2 JSON.stringify() 的改造","link":"/2020/05/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"前端基础/es6/unicode/unicode及其它转码","text":"","link":"/2020/05/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/unicode/unicode%E5%8F%8A%E5%85%B6%E5%AE%83%E8%BD%AC%E7%A0%81/"},{"title":"Http请求-Guzzle","text":"Guzzle 库是一套强大的 PHP HTTP 请求套件，我们使用 Guzzle 的 HTTP 客户端来请求接口。 作用&amp;功能Guzzle 库是一套强大的 PHP HTTP 请求套件，我们使用 Guzzle 的 HTTP 客户端来请求接口。 安装Composer 安装1composer require &quot;guzzlehttp/guzzle:~6.3&quot; 配置生成配置文件，存放位置 config/debugbar.php： 1php artisan vendor:publish --provider=&quot;Mews\\Purifier\\PurifierServiceProvider&quot; 请将配置信息替换为以下: config/purifier.php 123456789101112131415161718&lt;?phpreturn [ 'encoding' =&gt; 'UTF-8', 'finalize' =&gt; true, 'cachePath' =&gt; storage_path('app/purifier'), 'cacheFileMode' =&gt; 0755, 'settings' =&gt; [ 'user_topic_body' =&gt; [ 'HTML.Doctype' =&gt; 'XHTML 1.0 Transitional', 'HTML.Allowed' =&gt; 'div,b,strong,i,em,a[href|title],ul,ol,ol[start],li,p[style],br,span[style],img[width|height|alt|src],*[style|class],pre,hr,code,h2,h3,h4,h5,h6,blockquote,del,table,thead,tbody,tr,th,td', 'CSS.AllowedProperties' =&gt; 'font,font-size,font-weight,font-style,margin,width,height,font-family,text-decoration,padding-left,color,background-color,text-align', 'AutoFormat.AutoParagraph' =&gt; true, 'AutoFormat.RemoveEmpty' =&gt; true, ], ],]; 使用配置里的 user_topic_body 是我们为话题内容定制的，配合 clean() 方法使用： 1$topic-&gt;body = clean($topic-&gt;body, 'user_topic_body'); user_topic_body是config配置里的 123456789101112131415return [ 'encoding' =&gt; 'UTF-8', 'finalize' =&gt; true, 'cachePath' =&gt; storage_path('app/purifier'), 'cacheFileMode' =&gt; 0755, 'settings' =&gt; [ 'user_topic_body' =&gt; [ 'HTML.Doctype' =&gt; 'XHTML 1.0 Transitional', 'HTML.Allowed' =&gt; 'div,b,strong,i,em,a[href|title],ul,ol,ol[start],li,p[style],br,span[style],img[width|height|alt|src],*[style|class],pre,hr,code,h2,h3,h4,h5,h6,blockquote,del,table,thead,tbody,tr,th,td', 'CSS.AllowedProperties' =&gt; 'font,font-size,font-weight,font-style,margin,width,height,font-family,text-decoration,padding-left,color,background-color,text-align', 'AutoFormat.AutoParagraph' =&gt; true, 'AutoFormat.RemoveEmpty' =&gt; true, ], ],]; 拓展","link":"/2020/05/19/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/Http%E8%AF%B7%E6%B1%82-Guzzle/"},{"title":"中文转英文-PinYin","text":"PinYin 是 安正超 开发的，基于 CC-CEDICT 词典的中文转拼音工具，是一套优质的汉字转拼音解决方案。我们使用 PinYin 来作为翻译的后备计划，当百度翻译 API 不可用时，程序会自动使用 PinYin 汉字转拼音方案来生成 Slug。 作用&amp;功能PinYin 是 安正超 开发的，基于 CC-CEDICT 词典的中文转拼音工具，是一套优质的汉字转拼音解决方案。我们使用 PinYin 来作为翻译的后备计划，当百度翻译 API 不可用时，程序会自动使用 PinYin 汉字转拼音方案来生成 Slug。 安装Composer 安装1composer require &quot;overtrue/pinyin:~3.0&quot; 配置使用拓展","link":"/2020/05/20/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E4%B8%AD%E6%96%87%E8%BD%AC%E8%8B%B1%E6%96%87-PinYin/"},{"title":"页面调优 Debugbar","text":"记录laravel基础的配置部署 作用&amp;功能使用 Intervention/image 扩展包来处理图片裁切的逻辑 安装Composer 安装1composer require &quot;barryvdh/laravel-debugbar:~3.1&quot; --dev 配置生成配置文件，存放位置 config/debugbar.php： 1php artisan vendor:publish --provider=&quot;Barryvdh\\Debugbar\\ServiceProvider&quot; 打开 config/debugbar.php，将 enabled 的值设置为： 1'enabled' =&gt; env('APP_DEBUG', false), 使用] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace App\\Handlers;use Image;class ImageUploadHandler{ protected $allowed_ext = [\"png\", \"jpg\", \"gif\", 'jpeg']; public function save($file, $folder, $file_prefix, $max_width = false) { // 构建存储的文件夹规则，值如：uploads/images/avatars/201709/21/ // 文件夹切割能让查找效率更高。 $folder_name = \"uploads/images/$folder/\" . date(\"Ym/d\", time()); // 文件具体存储的物理路径，`public_path()` 获取的是 `public` 文件夹的物理路径。 // 值如：/home/vagrant/Code/larabbs/public/uploads/images/avatars/201709/21/ $upload_path = public_path() . '/' . $folder_name; // 获取文件的后缀名，因图片从剪贴板里黏贴时后缀名为空，所以此处确保后缀一直存在 $extension = strtolower($file-&gt;getClientOriginalExtension()) ?: 'png'; // 拼接文件名，加前缀是为了增加辨析度，前缀可以是相关数据模型的 ID // 值如：1_1493521050_7BVc9v9ujP.png $filename = $file_prefix . '_' . time() . '_' . str_random(10) . '.' . $extension; // 如果上传的不是图片将终止操作 if ( ! in_array($extension, $this-&gt;allowed_ext)) { return false; } // 将图片移动到我们的目标存储路径中 $file-&gt;move($upload_path, $filename); // 如果限制了图片宽度，就进行裁剪 if ($max_width &amp;&amp; $extension != 'gif') { // 此类中封装的函数，用于裁剪图片 $this-&gt;reduceSize($upload_path . '/' . $filename, $max_width); } return [ 'path' =&gt; config('app.url') . \"/$folder_name/$filename\" ]; } public function reduceSize($file_path, $max_width) { // 先实例化，传参是文件的磁盘物理路径 $image = Image::make($file_path); // 进行大小调整的操作 $image-&gt;resize($max_width, null, function ($constraint) { // 设定宽度是 $max_width，高度等比例双方缩放 $constraint-&gt;aspectRatio(); // 防止裁图时图片尺寸变大 $constraint-&gt;upsize(); }); // 对图片修改后进行保存 $image-&gt;save(); }} 拓展","link":"/2020/05/17/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/Debugbar/"},{"title":"防止xss攻击HTMLPurifier","text":"记录laravel基础的配置部署 作用&amp;功能使用 Intervention/image 扩展包来处理图片裁切的逻辑 安装Composer 安装1composer require &quot;mews/purifier:~2.0&quot; 配置生成配置文件，存放位置 config/debugbar.php： 1php artisan vendor:publish --provider=&quot;Mews\\Purifier\\PurifierServiceProvider&quot; 请将配置信息替换为以下: config/purifier.php 123456789101112131415161718&lt;?phpreturn [ 'encoding' =&gt; 'UTF-8', 'finalize' =&gt; true, 'cachePath' =&gt; storage_path('app/purifier'), 'cacheFileMode' =&gt; 0755, 'settings' =&gt; [ 'user_topic_body' =&gt; [ 'HTML.Doctype' =&gt; 'XHTML 1.0 Transitional', 'HTML.Allowed' =&gt; 'div,b,strong,i,em,a[href|title],ul,ol,ol[start],li,p[style],br,span[style],img[width|height|alt|src],*[style|class],pre,hr,code,h2,h3,h4,h5,h6,blockquote,del,table,thead,tbody,tr,th,td', 'CSS.AllowedProperties' =&gt; 'font,font-size,font-weight,font-style,margin,width,height,font-family,text-decoration,padding-left,color,background-color,text-align', 'AutoFormat.AutoParagraph' =&gt; true, 'AutoFormat.RemoveEmpty' =&gt; true, ], ],]; 使用配置里的 user_topic_body 是我们为话题内容定制的，配合 clean() 方法使用： 1$topic-&gt;body = clean($topic-&gt;body, 'user_topic_body'); user_topic_body是config配置里的 123456789101112131415return [ 'encoding' =&gt; 'UTF-8', 'finalize' =&gt; true, 'cachePath' =&gt; storage_path('app/purifier'), 'cacheFileMode' =&gt; 0755, 'settings' =&gt; [ 'user_topic_body' =&gt; [ 'HTML.Doctype' =&gt; 'XHTML 1.0 Transitional', 'HTML.Allowed' =&gt; 'div,b,strong,i,em,a[href|title],ul,ol,ol[start],li,p[style],br,span[style],img[width|height|alt|src],*[style|class],pre,hr,code,h2,h3,h4,h5,h6,blockquote,del,table,thead,tbody,tr,th,td', 'CSS.AllowedProperties' =&gt; 'font,font-size,font-weight,font-style,margin,width,height,font-family,text-decoration,padding-left,color,background-color,text-align', 'AutoFormat.AutoParagraph' =&gt; true, 'AutoFormat.RemoveEmpty' =&gt; true, ], ],]; 拓展","link":"/2020/05/19/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E9%98%B2%E6%AD%A2xss%E6%94%BB%E5%87%BBHTMLPurifier/"},{"title":"图片处理 intervention/image","text":"记录laravel基础的配置部署 作用&amp;功能使用 Intervention/image 扩展包来处理图片裁切的逻辑 安装Composer 安装1composer require intervention/image 配置1php artisan vendor:publish --provider=&quot;Intervention\\Image\\ImageServiceProviderLaravel5&quot; 打开 config/image.php 文件可以看到只有一个驱动器的选项，支持的值有 GD 库 和 ImageMagic： 使用] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpnamespace App\\Handlers;use Image;class ImageUploadHandler{ protected $allowed_ext = [\"png\", \"jpg\", \"gif\", 'jpeg']; public function save($file, $folder, $file_prefix, $max_width = false) { // 构建存储的文件夹规则，值如：uploads/images/avatars/201709/21/ // 文件夹切割能让查找效率更高。 $folder_name = \"uploads/images/$folder/\" . date(\"Ym/d\", time()); // 文件具体存储的物理路径，`public_path()` 获取的是 `public` 文件夹的物理路径。 // 值如：/home/vagrant/Code/larabbs/public/uploads/images/avatars/201709/21/ $upload_path = public_path() . '/' . $folder_name; // 获取文件的后缀名，因图片从剪贴板里黏贴时后缀名为空，所以此处确保后缀一直存在 $extension = strtolower($file-&gt;getClientOriginalExtension()) ?: 'png'; // 拼接文件名，加前缀是为了增加辨析度，前缀可以是相关数据模型的 ID // 值如：1_1493521050_7BVc9v9ujP.png $filename = $file_prefix . '_' . time() . '_' . str_random(10) . '.' . $extension; // 如果上传的不是图片将终止操作 if ( ! in_array($extension, $this-&gt;allowed_ext)) { return false; } // 将图片移动到我们的目标存储路径中 $file-&gt;move($upload_path, $filename); // 如果限制了图片宽度，就进行裁剪 if ($max_width &amp;&amp; $extension != 'gif') { // 此类中封装的函数，用于裁剪图片 $this-&gt;reduceSize($upload_path . '/' . $filename, $max_width); } return [ 'path' =&gt; config('app.url') . \"/$folder_name/$filename\" ]; } public function reduceSize($file_path, $max_width) { // 先实例化，传参是文件的磁盘物理路径 $image = Image::make($file_path); // 进行大小调整的操作 $image-&gt;resize($max_width, null, function ($constraint) { // 设定宽度是 $max_width，高度等比例双方缩放 $constraint-&gt;aspectRatio(); // 防止裁图时图片尺寸变大 $constraint-&gt;upsize(); }); // 对图片修改后进行保存 $image-&gt;save(); }} 拓展","link":"/2020/05/16/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%83%A8%E7%BD%B2/"},{"title":"队列-predis","text":"队列允许你异步执行消耗时间的任务，比如请求一个 API 并等待返回的结果。这样可以有效的降低请求响应的时间。 作用&amp;功能队列允许你异步执行消耗时间的任务，比如请求一个 API 并等待返回的结果。这样可以有效的降低请求响应的时间。 安装Composer 安装1composer require &quot;predis/predis:~1.0&quot; 配置 接下来我们还需要修改环境变量 QUEUE_DRIVER 的值为 redis： .env 1QUEUE_DRIVER=redis 使用拓展有时候队列中的任务会失败。Laravel 内置了一个方便的方式来指定任务重试的最大次数。当任务超出这个重试次数后，它就会被插入到 failed_jobs 数据表里面。我们可以使用 queue:failed-table 命令来创建 failed_jobs表的迁移文件： 1php artisan queue:failed-table 接着使用 migrate Artisan 命令生成 failed_jobs 表： 1php artisan migrate 生成任务类使用以下 Artisan 命令来生成一个新的队列任务： 1php artisan make:job TranslateSlug 该命令会在 app/Jobs 目录下生成一个新的类： 123456789101112131415161718192021222324252627282930313233343536app/Jobs/TranslateSlug.php&lt;?phpnamespace App\\Jobs;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;use App\\Models\\Topic;use App\\Handlers\\SlugTranslateHandler;class TranslateSlug implements ShouldQueue{ use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $topic; public function __construct(Topic $topic) { // 队列任务构造器中接收了 Eloquent 模型，将会只序列化模型的 ID $this-&gt;topic = $topic; } public function handle() { // 请求百度 API 接口进行翻译 $slug = app(SlugTranslateHandler::class)-&gt;translate($this-&gt;topic-&gt;title); // 为了避免模型监控器死循环调用，我们使用 DB 类直接对数据库进行操作 \\DB::table('topics')-&gt;where('id', $this-&gt;topic-&gt;id)-&gt;update(['slug' =&gt; $slug]); }} 该类实现了 Illuminate\\Contracts\\Queue\\ShouldQueue 接口，该接口表明 Laravel 应该将该任务添加到后台的任务队列中，而不是同步执行。 引入了 SerializesModels trait，Eloquent 模型会被优雅的序列化和反序列化。队列任务构造器中接收了 Eloquent 模型，将会只序列化模型的 ID。这样子在任务执行时，队列系统会从数据库中自动的根据 ID 检索出模型实例。这样可以避免序列化完整的模型可能在队列中出现的问题。 handle 方法会在队列任务执行时被调用。值得注意的是，我们可以在任务的 handle 方法中可以使用类型提示来进行依赖的注入。Laravel 的服务容器会自动的将这些依赖注入进去，与控制器方法类似。 还有一点需要注意，我们将会在模型监控器中分发任务，任务中要避免使用 Eloquent 模型接口调用，如：create(), update(), save() 等操作。否则会陷入调用死循环 —— 模型监控器分发任务，任务触发模型监控器，模型监控器再次分发任务，任务再次触发模型监控器…. 死循环。在这种情况下，使用 DB 类直接对数据库进行操作即可。 任务分发接下来我们要修改 Topic 模型监控器，将 Slug 翻译的调用修改为队列执行的方式： 123456789101112131415161718192021222324252627282930app/Observers/TopicObserver.php&lt;?phpnamespace App\\Observers;use App\\Models\\Topic;use App\\Jobs\\TranslateSlug;// creating, created, updating, updated, saving,// saved, deleting, deleted, restoring, restoredclass TopicObserver{ public function saving(Topic $topic) { // XSS 过滤 $topic-&gt;body = clean($topic-&gt;body, 'user_topic_body'); // 生成话题摘录 $topic-&gt;excerpt = make_excerpt($topic-&gt;body); // 如 slug 字段无内容，即使用翻译器对 title 进行翻译 if ( ! $topic-&gt;slug) { // 推送任务到队列 dispatch(new TranslateSlug($topic)); } }} 开始测试开始之前，我们需要在命令行启动队列系统，队列在启动完成后会进入监听状态： 1php artisan queue:listen","link":"/2020/05/20/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E9%98%9F%E5%88%97-predis/"},{"title":"权限管理-laravel-permission","text":"Laravel-permission 作用&amp;功能 Laravel-permission 安装Composer 安装1composer require &quot;spatie/laravel-permission:~2.7&quot; 生成数据库迁移文件： 1php artisan vendor:publish --provider=&quot;Spatie\\Permission\\PermissionServiceProvider&quot; --tag=&quot;migrations&quot; 配置 下图是 laravel-permission 的数据库表结构： 数据表各自的作用： roles —— 角色的模型表； permissions —— 权限的模型表； model_has_roles —— 模型与角色的关联表，用户拥有什么角色在此表中定义，一个用户能拥有多个角色； role_has_permissions —— 角色拥有的权限关联表，如管理员拥有查看后台的权限都是在此表定义，一个角色能拥有多个权限； model_has_permissions —— 模型与权限关联表，一个模型能拥有多个权限。 使用1php artisan migrate 生成配置信息： 1php artisan vendor:publish --provider=&quot;Spatie\\Permission\\PermissionServiceProvider&quot; --tag=&quot;config&quot; 配置信息存放于 config/permission.php ，可以打开此文件瞧一瞧，目前我们不需要做任何修改。 加载 HasRoles 我们还需在 User 中使用 laravel-permission 提供的 Trait —— HasRoles，此举能让我们获取到扩展包提供的所有权限和角色的操作方法。 app/Models/User.php 123456789use Spatie\\Permission\\Traits\\HasRoles;class User extends Authenticatable{ use HasRoles; . . .} 初始化角色和权限拓展","link":"/2020/05/24/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-laravel-permission/"},{"title":"权限验证方法集合","text":"权限验证方法集合 中间件Middleware策略Policy","link":"/2020/05/17/php/laravel/%E6%9D%83%E9%99%90/%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/"},{"title":"Jwt-Auth实现API用户认证、刷新令牌","text":"概述：JWT： JWT（JSON Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。更详细讲解地址：https://laravelacademy.org/post/3640.html 应用场景：前后端分离的项目原理：http协议是无状态的，当项目需要用户保存在线时就需要一种介质来保持 使用自定义认证中间件实现效果：提供账号密码前来登录。如果登录成功，那么我会给前端颁发一个 access_token ，设置在 header 中以请求需要用户认证的路由。如果用户的令牌如果过期了，可以暂时通过此次请求，并在此次请求中刷新该用户的 access_token，最后在响应头中将新的 access_token 返回给前端，这样子可以无痛的刷新 access_token，用户可以获得一个很良好的体验，所以开始动手写代码。 执行如下命令以新建一个中间件： 1php artisan make:middleware RefreshToken 中间件app\\Http\\Middleware\\RefreshToken.php代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\\Http\\Middleware;use Auth;use Closure;use Tymon\\JWTAuth\\Exceptions\\JWTException;use Tymon\\JWTAuth\\Http\\Middleware\\BaseMiddleware;use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException;use Symfony\\Component\\HttpKernel\\Exception\\UnauthorizedHttpException;// 注意，我们要继承的是 jwt 的 BaseMiddlewareclass RefreshToken extends BaseMiddleware{ /** * @param $request * @param Closure $next * @return \\Illuminate\\Http\\JsonResponse|\\Illuminate\\Http\\Response|mixed * @throws JWTException */ public function handle($request, Closure $next) { // 检查此次请求中是否带有 token，如果没有则抛出异常。 $this-&gt;checkForToken($request); // 使用 try 包裹，以捕捉 token 过期所抛出的 TokenExpiredException 异常 try { // 检测用户的登录状态，如果正常则通过 if ($this-&gt;auth-&gt;parseToken()-&gt;authenticate()) { return $next($request); } throw new UnauthorizedHttpException('jwt-auth', '未登录'); } catch (TokenExpiredException $exception) { // 此处捕获到了 token 过期所抛出的 TokenExpiredException 异常，我们在这里需要做的是刷新该用户的 token 并将它添加到响应头中 try { // 刷新用户的 token $token = $this-&gt;auth-&gt;refresh(); // 使用一次性登录以保证此次请求的成功 Auth::guard('api')-&gt;onceUsingId($this-&gt;auth-&gt;manager()-&gt;getPayloadFactory()-&gt;buildClaimsCollection()-&gt;toPlainArray()['sub']); } catch (JWTException $exception) { // 如果捕获到此异常，即代表 refresh 也过期了，用户无法刷新令牌，需要重新登录。 throw new UnauthorizedHttpException('jwt-auth', $exception-&gt;getMessage()); } } // 在响应头中返回新的 token return $this-&gt;setAuthenticationHeader($next($request), $token); }} 然后我们注册一下中间件，文件位置app\\Http\\Kernel.php在路由处会使用 123protected $routeMiddleware = [ 'refresh' =&gt; \\App\\Http\\Middleware\\RefreshToken::class,] 更新异常处理的 Handler 由于我们构建的是 api 服务，所以我们需要更新一下 app/Exceptions/Handler.php 中的 render方法，自定义处理一些异常。 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Exceptions;use Exception;use Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;use Illuminate\\Validation\\ValidationException;use Symfony\\Component\\HttpKernel\\Exception\\UnauthorizedHttpException;class Handler extends ExceptionHandler{ ... /** * Render an exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $exception) { // 参数验证错误的异常，我们需要返回 400 的 http code 和一句错误信息 if ($exception instanceof ValidationException) { return response(['error' =&gt; array_first(array_collapse($exception-&gt;errors()))], 400); } // 用户认证的异常，我们需要返回 401 的 http code 和错误信息 if ($exception instanceof UnauthorizedHttpException) { return response($exception-&gt;getMessage(), 401); } return parent::render($request, $exception); }}","link":"/2020/05/05/php/laravel/%E6%9D%83%E9%99%90/%E4%BD%BF%E7%94%A8%20Jwt-Auth%20%E5%AE%9E%E7%8E%B0%20API%20%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E3%80%81%E5%88%B7%E6%96%B0%E4%BB%A4%E7%89%8C/"},{"title":"队列监控器-Horizon","text":"Horizon 是 Laravel 生态圈里的一员，为 Laravel Redis 队列提供了一个漂亮的仪表板，允许我们很方便地查看和管理 Redis 队列任务执行的情况。 作用&amp;功能Horizon 是 Laravel 生态圈里的一员，为 Laravel Redis 队列提供了一个漂亮的仪表板，允许我们很方便地查看和管理 Redis 队列任务执行的情况。 安装Composer 安装1composer require &quot;laravel/horizon:~1.0&quot; 配置安装完成后，使用 vendor:publish Artisan 命令发布相关文件： 1php artisan vendor:publish --provider=&quot;Laravel\\Horizon\\HorizonServiceProvider&quot; 使用Horizon 是一个监控程序，需要常驻运行，我们可以通过以下命令启动： 1php artisan horizon 安装了 Horizon 以后，我们将使用 horizon 命令来启动队列系统和任务监控，无需使用 queue:listen。 线上部署须知在开发环境中，我们为了测试方便，直接在命令行里调用 artisan horizon 进行队列监控。然而在生产环境中，我们需要配置一个进程管理工具来监控 artisan horizon 命令的执行，以便在其意外退出时自动重启。当服务器部署新代码时，需要终止当前 Horizon 主进程，然后通过进程管理工具来重启，从而使用最新的代码。 简而言之，生产环境下使用队列需要注意以下两个问题： 使用 Supervisor 进程工具进行管理，配置和使用请参照 文档 进行配置；每一次部署代码时，需 artisan horizon:terminate 然后再 artisan horizon 重新加载代码。线上部署的话，还要注意一个权限控制的问题，我们将在后面章节中讲到。 拓展","link":"/2020/05/20/php/laravel/%E6%89%A9%E5%B1%95%E5%8C%85/%E9%98%9F%E5%88%97%E7%9B%91%E6%8E%A7%E5%99%A8-Horizon/"},{"title":"购物车实现流程","text":"购物车实现流程 购物车流程 判断用户是否登录 小程序初始的时候请求获取购物车商品接口并保存数据到本地缓存localstorage 添加商品到购物车，更新本地缓存的数据，实时提交到数据库 打开购物车页面提交购物车商品本地缓存到服务器，判断是否需要更新数据库数据 购物车页面修改商品信息， 判断用户是否登录加载购物车商品信息到本地缓存添加商品到购物车购物车页面更改商品信息总结","link":"/2020/05/24/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E5%AE%9E%E4%BE%8B/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%95%86%E5%9F%8E/%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%B5%81%E7%A8%8B/"},{"title":"项目基础部署","text":"记录laravel基础的配置部署 安装两种安装laravel项目方式： laravel安装器1234composer global require &quot;laravel/installer&quot;// 创建项目laravel new garmin 通过composer拉取laravel包1composer create-project --prefer-dist laravel/laravel garmin &quot;5.5.*&quot; 配置新创建的项目需要进行配置， 配置文件env在laravel程序获取配置时会先进行对.env 文件访问，获取相应配置，.env在团队开发时可以有效的使成员熟悉配置，和避免敏感信息提交到github等开源库有个env模板.env.example将它复制重命名再配置项目 1cp -a .env.example .env 生成AppKeylaravel 将密钥用于所有加密的 cookie (包括会话 cookie)，然后再将其交给用户浏览器，并使用它解密从浏览器读取的 cookie。这样可以防止客户端更改其 cookie 并为其授予管理员特权或模拟应用程序中的其他用户。加密的 cookie 是 Laravel 中的重要安全特性。生产key 1php artisan key:generate 到此项目就可以运行起来了！！！ 添加自定义公共函数 创建自定义的公共函数 1touch boostrap/heplers.php 把自定义文件添加到自动加载中在根目录下的composer.json文件下的autoload 添加配置 1&quot;files&quot;: [ &quot;app/helpers.php&quot; ]; 修改保存后运行以下命令进行重新加载文件即可： 1composer dump-autoload","link":"/2020/05/14/php/laravel/%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%83%A8%E7%BD%B2/"},{"title":"es6知识点","text":"字符串 anchor创建一个锚点 12345var txt=\"Hello Garmin!\"document.write(txt.anchor(\"garmin\"))// html// &lt;a name=\"garmin\"&gt;Hello Garmin!&lt;/a&gt; 上面创建了一个名称为 garmin 的锚点 big123var txt=\"Hello Garmin!\"txt.big();// \"&lt;big&gt;Hello Garmin!&lt;/big&gt;\" blink123var txt=\"Hello Garmin!\"txt.big();// \"&lt;blink&gt;Hello Garmin!&lt;/blink&gt;\" bold123var txt=\"Hello Garmin!\"txt.blod();// \"&lt;b&gt;garmin&lt;/b&gt;\" fixed1234var txt=\"Hello Garmin!\";txt.fixed() // \"&lt;tt&gt;Hello Garmin!&lt;/tt&gt;\" fontcolor1234var txt=\"Hello Garmin!\";txt.fontcolor('red') \"&lt;font color='red'&gt;Hello Garmin!&lt;/font&gt;\" fontsize1234var txt=\"Hello Garmin!\";txt.fontsize(20) \"&lt;font size='20'&gt;Hello Garmin!&lt;/font&gt;\" italics123var txt=\"Hello Garmin!\";txt.italics() \"&lt;i&gt;Hello Garmin!&lt;/i&gt;\" link123var txt=\"Hello Garmin!\";txt.link('baidu.com') \"&lt;a href='baidu.com'&gt;Hello Garmin!&lt;/a&gt;\" 以上的方法好鸡肋啊！！！ charAt根据指定位置（position）查找字符，返回值为当前指定位置的字符 1234var txt=\"Hello Garmin!\";txt.charAt(6);\"G\" charCodeAt / codePointAt方法可返回指定位置的字符的 Unicode 编码 1234var txt=\"Hello Garmin!\";txt.charCodeAt(0);\"72\" concat字符串连接 123var txt=\"Hello Garmin!\";txt.concat(' my name is bobo');// Hello Garmin! my name is bobo 和连接符+有差异？ constructor构造方法 1234var txt=\"Hello Garmin!\";txt.constructor === Stringtrue 可以用来判断变量的类型 还不错！ endsWith / startsWithendsWith 判断结束字符，参数匹配字符，放回布尔值。 startsWith 相反 1234var txt=\"Hello Garmin!\";txt.endsWith('!') // truetxt.endsWith('?') // false includes查找指定字符串是否存在该字符串searchvalue： 必需，要查找的字符串。start：可选，设置从哪个位置开始查找，默认为 0。返回布尔型 123var txt=\"Hello Garmin!\";txt.includes('Garmin') // truetxt.includes('Garmin', 7) // false indexOf / lastIndexOf查找字符出现的位置searchvalue:必需。规定需检索的字符串值。fromindex: 可选，设置从哪个位置开始查找，默认为 0。 123var txt=\"Hello Garmin!\";txt.indexOf('G') // 6txt.indexOf('G', 7) // -1 length无需多言 返回字符串长度 localeCompare1234var txt=\"Hello Garmin!\";txt.localeCompare('Hello Garmin!') // 0txt.indexOf('xyz') // -1txt.indexOf('abc') // 1 0 : 字符串匹配100% 1 : 不匹配，参数值来自于语言环境的排序顺序字符串对象的值之前 -1 : 不匹配，参数值来自于语言环境的排序顺序字符串对象的值之后 match查找字符searchvalue 必需。规定要检索的字符串值。返回字符位置或者 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 123var txt=\"Hello Garmin!\";txt.match('n') // 11txt.match(/\\w/g) // [\"H\", \"e\", \"l\", \"l\", \"o\", \"G\", \"a\", \"r\", \"m\", \"i\", \"n\"] normalize12let txt = \"\\u4F60\\u597D \\u4F73\\u660E\\uFF01\";console.log(txt.normalize('NFC')) // 你好佳明 padEnd / padStart填充字符到指定长度, padEnd后面追加，padStart`相反 123let txt = \"Hello Garmin!\";console.log(txt.padEnd(20, '&amp;&amp;--'))//Hello Garmin!&amp;&amp;--&amp;&amp;-","link":"/2020/05/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"},{"title":"正则","text":"\\1 \\2 \\3匹配这种写法需要搭配括号()! \\1 是在当前位置重复匹配第一个括号()里的表达式的值，\\2 \\3以此类推！！！ 123var str = 'a1a123';str.match(/(\\w)(.)\\1/g); // [\"a1a\"]str.match(/(\\w)(.)\\1\\2/g); // [\"a1a1\"] 应用场景 可以用来匹配重复的字符串","link":"/2020/06/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/es6/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99/"},{"title":"上传base64报错问题","text":"上传base64报错问题,base64格式的字符非常膨大，不能使用params了，要使用data 报错 提交用data 不能使用params了！","link":"/2020/06/18/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%AF%B7%E6%B1%82/%E4%B8%8A%E4%BC%A0base64%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"表格","slug":"表格","link":"/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","link":"/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"},{"name":"js题目","slug":"js题目","link":"/tags/js%E9%A2%98%E7%9B%AE/"},{"name":"plan","slug":"plan","link":"/tags/plan/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"mixins","slug":"mixins","link":"/tags/mixins/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"登录","slug":"登录","link":"/tags/%E7%99%BB%E5%BD%95/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"状态管理","slug":"状态管理","link":"/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"遍历","slug":"遍历","link":"/tags/%E9%81%8D%E5%8E%86/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"laravel扩展包","slug":"laravel扩展包","link":"/tags/laravel%E6%89%A9%E5%B1%95%E5%8C%85/"},{"name":"auth","slug":"auth","link":"/tags/auth/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"articles","slug":"articles","link":"/categories/articles/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"laravel","slug":"php/laravel","link":"/categories/php/laravel/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"es6","slug":"es6","link":"/categories/es6/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"auth","slug":"php/laravel/auth","link":"/categories/php/laravel/auth/"}]}